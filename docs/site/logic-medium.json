{
  "title": "Logic Building Problems - Medio",
  "description": "Problemas de nivel medio para construcci√≥n avanzada de l√≥gica de programaci√≥n",
  "version": "1.0",
  "lastUpdated": "2025-08-21",
  "difficulty": "medium",
  "section": {
    "id": "logic-medium",
    "title": "üü† Logic Building - Problemas Medios",
    "description": "Problemas de nivel intermedio para desarrollar l√≥gica avanzada de programaci√≥n",
    "subsections": [
      {
        "id": "square-root",
        "title": "Square Root Implementation",
        "type": "logic-problem",
        "content": "<strong>Problema:</strong> Implementar funci√≥n para calcular ra√≠z cuadrada sin usar Math.sqrt().<br><br><strong>Ejemplos:</strong><br>‚Ä¢ Input: 25, Output: 5<br>‚Ä¢ Input: 8, Output: 2.828... (aproximado)<br><br><strong>M√©todo de Newton-Raphson:</strong><br>```javascript<br>function sqrt(x, precision = 1e-10) {<br>    if (x < 0) return NaN;<br>    if (x === 0) return 0;<br>    <br>    let guess = x / 2;<br>    while (Math.abs(guess * guess - x) > precision) {<br>        guess = (guess + x / guess) / 2;<br>    }<br>    return guess;<br>}<br>```<br><br><strong>B√∫squeda Binaria:</strong><br>```javascript<br>function sqrt(x, precision = 1e-6) {<br>    if (x < 0) return NaN;<br>    if (x < 1) return sqrtFraction(x);<br>    <br>    let left = 0, right = x;<br>    while (right - left > precision) {<br>        let mid = (left + right) / 2;<br>        if (mid * mid > x) {<br>            right = mid;<br>        } else {<br>            left = mid;<br>        }<br>    }<br>    return (left + right) / 2;<br>}<br>```<br><br><strong>L√≥gica:</strong> Aproximaci√≥n iterativa usando m√©todos num√©ricos."
      },
      {
        "id": "three-divisors",
        "title": "Numbers with Exactly 3 Divisors",
        "type": "logic-problem",
        "content": "<strong>Problema:</strong> Encontrar n√∫meros que tengan exactamente 3 divisores.<br><br><strong>Propiedad:</strong> Solo los cuadrados de n√∫meros primos tienen exactamente 3 divisores.<br><br><strong>Ejemplos:</strong><br>‚Ä¢ Input: limit = 50, Output: [4, 9, 25, 49]<br>‚Ä¢ Explicaci√≥n: 4=2¬≤, 9=3¬≤, 25=5¬≤, 49=7¬≤<br><br><strong>Soluci√≥n Eficiente:</strong><br>```javascript<br>function isPrime(n) {<br>    if (n <= 1) return false;<br>    if (n <= 3) return true;<br>    if (n % 2 === 0 || n % 3 === 0) return false;<br>    <br>    for (let i = 5; i * i <= n; i += 6) {<br>        if (n % i === 0 || n % (i + 2) === 0) return false;<br>    }<br>    return true;<br>}<br><br>function numbersWithThreeDivisors(limit) {<br>    const result = [];<br>    for (let i = 2; i * i <= limit; i++) {<br>        if (isPrime(i)) {<br>            result.push(i * i);<br>        }<br>    }<br>    return result;<br>}<br>```<br><br><strong>Verificaci√≥n por conteo:</strong><br>```javascript<br>function countDivisors(n) {<br>    let count = 0;<br>    for (let i = 1; i * i <= n; i++) {<br>        if (n % i === 0) {<br>            count += (i * i === n) ? 1 : 2;<br>        }<br>    }<br>    return count;<br>}<br>```<br><br><strong>L√≥gica:</strong> Los n√∫meros con exactamente 3 divisores son cuadrados de primos."
      },
      {
        "id": "divisible-by-4",
        "title": "Divisibility by 4",
        "type": "logic-problem",
        "content": "<strong>Problema:</strong> Verificar si un n√∫mero es divisible por 4 sin usar operador m√≥dulo.<br><br><strong>Regla:</strong> Un n√∫mero es divisible por 4 si sus √∫ltimos dos d√≠gitos forman un n√∫mero divisible por 4.<br><br><strong>Ejemplos:</strong><br>‚Ä¢ Input: 1236, Output: true (36 es divisible por 4)<br>‚Ä¢ Input: 1234, Output: false (34 no es divisible por 4)<br><br><strong>Soluci√≥n con String:</strong><br>```javascript<br>function isDivisibleBy4(num) {<br>    const str = num.toString();<br>    const lastTwoDigits = str.length >= 2 ? <br>        parseInt(str.slice(-2)) : num;<br>    return lastTwoDigits % 4 === 0;<br>}<br>```<br><br><strong>Soluci√≥n Matem√°tica:</strong><br>```javascript<br>function isDivisibleBy4(num) {<br>    const lastTwoDigits = num % 100;<br>    return lastTwoDigits % 4 === 0;<br>}<br>```<br><br><strong>Sin usar m√≥dulo (m√©todo de bits):</strong><br>```javascript<br>function isDivisibleBy4(num) {<br>    // Un n√∫mero es divisible por 4 si los √∫ltimos 2 bits son 00<br>    return (num & 3) === 0;<br>}<br>```<br><br><strong>M√©todo alternativo sin m√≥dulo:</strong><br>```javascript<br>function isDivisibleBy4(num) {<br>    while (num > 4) {<br>        num -= 4;<br>    }<br>    return num === 0 || num === 4;<br>}<br>```<br><br><strong>L√≥gica:</strong> Aplicar reglas de divisibilidad o manipulaci√≥n de bits."
      },
      {
        "id": "divisibility-by-11",
        "title": "Divisibility by 11",
        "type": "logic-problem",
        "content": "<strong>Problema:</strong> Verificar si un n√∫mero es divisible por 11 usando la regla alternante.<br><br><strong>Regla:</strong> Un n√∫mero es divisible por 11 si la suma alternante de sus d√≠gitos es divisible por 11.<br><br><strong>Ejemplos:</strong><br>‚Ä¢ Input: 121, Output: true (1-2+1 = 0, divisible por 11)<br>‚Ä¢ Input: 1331, Output: true (1-3+3-1 = 0)<br><br><strong>Soluci√≥n:</strong><br>```javascript<br>function isDivisibleBy11(num) {<br>    const str = num.toString();<br>    let sum = 0;<br>    <br>    for (let i = 0; i < str.length; i++) {<br>        const digit = parseInt(str[i]);<br>        sum += (i % 2 === 0) ? digit : -digit;<br>    }<br>    <br>    return sum % 11 === 0;<br>}<br>```<br><br><strong>Versi√≥n Matem√°tica:</strong><br>```javascript<br>function isDivisibleBy11(num) {<br>    let oddSum = 0, evenSum = 0;<br>    let isOddPosition = true;<br>    <br>    while (num > 0) {<br>        if (isOddPosition) {<br>            oddSum += num % 10;<br>        } else {<br>            evenSum += num % 10;<br>        }<br>        num = Math.floor(num / 10);<br>        isOddPosition = !isOddPosition;<br>    }<br>    <br>    return Math.abs(oddSum - evenSum) % 11 === 0;<br>}<br>```<br><br><strong>M√©todo Recursivo:</strong><br>```javascript<br>function isDivisibleBy11(num) {<br>    if (num < 11) return num === 0;<br>    return isDivisibleBy11(Math.abs(Math.floor(num / 10) - (num % 10)));<br>}<br>```<br><br><strong>L√≥gica:</strong> Aplicar la regla de divisibilidad alternante para 11."
      },
      {
        "id": "divisibility-by-13",
        "title": "Divisibility by 13",
        "type": "logic-problem",
        "content": "<strong>Problema:</strong> Verificar divisibilidad por 13 usando algoritmo de resta alternante.<br><br><strong>Regla:</strong> Alternativamente sumar y restar bloques de 3 d√≠gitos desde la derecha, multiplicando por potencias de 1000 mod 13.<br><br><strong>Ejemplos:</strong><br>‚Ä¢ Input: 1001, Output: true (1001 = 7√ó11√ó13)<br>‚Ä¢ Input: 169, Output: true (169 = 13¬≤)<br><br><strong>M√©todo Simple:</strong><br>```javascript<br>function isDivisibleBy13(num) {<br>    return num % 13 === 0;<br>}<br>```<br><br><strong>M√©todo de Resta Alternante:</strong><br>```javascript<br>function isDivisibleBy13(num) {<br>    if (num < 13) return num === 0;<br>    <br>    // Quitar √∫ltimo d√≠gito y restar 4 veces ese d√≠gito<br>    const lastDigit = num % 10;<br>    const remaining = Math.floor(num / 10);<br>    const newNum = remaining - 4 * lastDigit;\r>    <br>    return isDivisibleBy13(Math.abs(newNum));<br>}<br>```<br><br><strong>M√©todo de Bloques:</strong><br>```javascript<br>function isDivisibleBy13(num) {<br>    const str = num.toString();<br>    let sum = 0;<br>    let sign = 1;<br>    \r>    // Procesar en bloques de 3 d√≠gitos desde la derecha<br>    for (let i = str.length; i > 0; i -= 3) {<br>        const start = Math.max(0, i - 3);<br>        const block = parseInt(str.substring(start, i));\r>        sum += sign * block;\r>        sign *= -1;\r>    }<r>    <br>    return Math.abs(sum) % 13 === 0;<br>}<br>```<br><br><strong>Verificaci√≥n por Tabla:</strong><br>```javascript<br>function isDivisibleBy13Table(num) {<br>    const remainders = [];<br>    while (num > 0 && !remainders.includes(num % 13)) {<br>        remainders.push(num % 13);<br>        num = Math.floor(num / 13);<br>    }<br>    return num === 0;\br>}<br>```<br><br><strong>L√≥gica:</strong> Aplicar algoritmos espec√≠ficos de divisibilidad por 13 o usar m√©todos de resta c√≠clica."
      },
      {
        "id": "kth-digit-power",
        "title": "K-th Digit in a^b",
        "type": "logic-problem",
        "content": "<strong>Problema:</strong> Encontrar el k-√©simo d√≠gito en a^b sin calcular el n√∫mero completo.<br><br><strong>Ejemplos:</strong><br>‚Ä¢ Input: a=2, b=10, k=3, Output: 4 (2^10 = 1024, 3er d√≠gito es 2)<br>‚Ä¢ Input: a=3, b=4, k=2, Output: 1 (3^4 = 81, 2do d√≠gito es 1)<br><br><strong>Usando BigInt (JavaScript):</strong><br>```javascript<br>function kthDigitInPower(a, b, k) {<br>    const power = BigInt(a) ** BigInt(b);<br>    const str = power.toString();<br>    <br>    if (k > str.length) return -1; // D√≠gito no existe<br>    <br>    return parseInt(str[k - 1]); // k-√©simo d√≠gito (1-indexed)<br>}\r>```<br><br><strong>M√©todo de Logaritmos (para estimaci√≥n):</strong><br>```javascript<br>function estimateDigitsInPower(a, b) {<br>    // N√∫mero de d√≠gitos en a^b es floor(b * log10(a)) + 1<br>    return Math.floor(b * Math.log10(a)) + 1;<br>}<br><br>function kthDigitApprox(a, b, k) {<br>    const totalDigits = estimateDigitsInPower(a, b);<br>    if (k > totalDigits) return -1;<br>    <br>    // Para n√∫meros muy grandes, necesitamos bibliotecas especiales\br>    // o algoritmos de aritm√©tica de precisi√≥n arbitraria<br>    return kthDigitInPower(a, b, k);\r>}<br>```<br><br><strong>Modular para √öltimos D√≠gitos:</strong><br>```javascript<br>function lastKDigitsOfPower(a, b, k) {<br>    let result = 1;<br>    const mod = Math.pow(10, k);\r>    a = a % mod;\r>    <br>    while (b > 0) {<br>        if (b % 2 === 1) {<br>            result = (result * a) % mod;<br>        }<br>        a = (a * a) % mod;<br>        b = Math.floor(b / 2);<br>    }<br>    <br>    return result;\r>}<br>```<br><br><strong>L√≥gica:</strong> Para n√∫meros peque√±os usar BigInt, para grandes necesitar aritm√©tica de precisi√≥n arbitraria."
      },
      {
        "id": "fraction-to-decimal",
        "title": "Fraction to Recurring Decimal",
        "type": "logic-problem",
        "content": "<strong>Problema:</strong> Convertir una fracci√≥n a su representaci√≥n decimal, detectando partes recurrentes.<br><br><strong>Ejemplos:</strong><br>‚Ä¢ Input: 1/3, Output: '0.(3)'<br>‚Ä¢ Input: 22/7, Output: '3.(142857)'<br>‚Ä¢ Input: 1/2, Output: '0.5'<br><br><strong>Soluci√≥n:</strong><br>```javascript<br>function fractionToDecimal(numerator, denominator) {<br>    if (numerator === 0) return '0';<br>    <br>    let result = '';<br>    <br>    // Manejar signo<br>    if ((numerator < 0) !== (denominator < 0)) {<br>        result += '-';<br>    }<r>    <br>    numerator = Math.abs(numerator);<br>    denominator = Math.abs(denominator);<r>    <br>    // Parte entera<br>    result += Math.floor(numerator / denominator);<br>    numerator %= denominator;<br>    <br>    if (numerator === 0) return result;<br>    <br>    result += '.';<br>    <br>    // Parte decimal<br>    const remainderMap = new Map();<br>    <br>    while (numerator !== 0) {<br>        if (remainderMap.has(numerator)) {<br>            const index = remainderMap.get(numerator);<br>            result = result.substring(0, index) + '(' + <br>                    result.substring(index) + ')';<br>            break;\r>        }<br>        <br>        remainderMap.set(numerator, result.length);<br>        numerator *= 10;<br>        result += Math.floor(numerator / denominator);<r>        numerator %= denominator;<r>    }<br>    <br>    return result;<br>}<br>```<br><br><strong>Detectar solo la parte recurrente:</strong><br>```javascript<br>function getRecurringPart(numerator, denominator) {<br>    const remainders = new Set();<br>    const sequence = [];<br>    <br>    numerator %= denominator;<r>    <br>    while (numerator !== 0 && !remainders.has(numerator)) {<br>        remainders.add(numerator);<br>        numerator *= 10;<br>        sequence.push(Math.floor(numerator / denominator));<r>        numerator %= denominator;<r>    }<br>    <br>    return numerator === 0 ? '' : sequence.join('');\r>}<br>```<br><br><strong>L√≥gica:</strong> Simular divisi√≥n larga y detectar cuando un residuo se repite."
      },
      {
        "id": "compute-npr",
        "title": "Compute nPr (Permutations)",
        "type": "logic-problem",
        "content": "<strong>Problema:</strong> Calcular el n√∫mero de permutaciones de n elementos tomados r a la vez.<br><br><strong>F√≥rmula:</strong> nPr = n! / (n-r)!<br><br><strong>Ejemplos:</strong><br>‚Ä¢ Input: n=5, r=3, Output: 60<br>‚Ä¢ Input: n=4, r=2, Output: 12<br><br><strong>Soluci√≥n Eficiente:</strong><br>```javascript<br>function nPr(n, r) {<br>    if (r > n || r < 0) return 0;<br>    if (r === 0) return 1;<br>    <br>    let result = 1;<br>    for (let i = n; i > n - r; i--) {<br>        result *= i;<br>    }<br>    return result;<br>}\r>```<br><br><strong>Con Factorials:</strong><br>```javascript<br>function factorial(n) {<br>    if (n <= 1) return 1;<br>    let result = 1;<br>    for (let i = 2; i <= n; i++) {<br>        result *= i;<br>    }<br>    return result;<br>}<br><br>function nPr(n, r) {<br>    if (r > n || r < 0) return 0;<br>    return factorial(n) / factorial(n - r);<br>}<br>```<br><br><strong>Recursivo:</strong><br>```javascript<br>function nPr(n, r) {<br>    if (r === 0) return 1;<br>    if (r > n) return 0;<br>    return n * nPr(n - 1, r - 1);<br>}<br>```<br><br><strong>Con BigInt para n√∫meros grandes:</strong><br>```javascript<br>function nPrBig(n, r) {<br>    if (r > n || r < 0) return 0n;<br>    if (r === 0) return 1n;\br>    <br>    let result = 1n;<br>    for (let i = BigInt(n); i > BigInt(n - r); i--) {<br>        result *= i;<br>    }<br>    return result;<br>}<br>```<br><br><strong>L√≥gica:</strong> Multiplicar n n√∫meros consecutivos descendentes desde n."
      },
      {
        "id": "compute-ncr",
        "title": "Compute nCr (Combinations)",
        "type": "logic-problem",
        "content": "<strong>Problema:</strong> Calcular el n√∫mero de combinaciones de n elementos tomados r a la vez.<br><br><strong>F√≥rmula:</strong> nCr = n! / (r! √ó (n-r)!)<br><br><strong>Ejemplos:</strong><br>‚Ä¢ Input: n=5, r=3, Output: 10<br>‚Ä¢ Input: n=4, r=2, Output: 6<br><br><strong>Soluci√≥n Optimizada:</strong><br>```javascript<br>function nCr(n, r) {<br>    if (r > n || r < 0) return 0;<br>    if (r === 0 || r === n) return 1;<br>    <br>    // Optimizaci√≥n: nCr = nC(n-r)<br>    r = Math.min(r, n - r);<br>    <br>    let result = 1;<br>    for (let i = 0; i < r; i++) {<br>        result = result * (n - i) / (i + 1);<br>    }<br>    return Math.round(result); // Redondear para evitar errores de punto flotante<br>}<br>```<br><br><strong>Versi√≥n Segura (evita overflow):</strong><br>```javascript<br>function nCr(n, r) {<br>    if (r > n || r < 0) return 0;<br>    if (r === 0 || r === n) return 1;<br>    <br>    r = Math.min(r, n - r);<br>    <br>    let numerator = 1;<br>    let denominator = 1;<br>    <br>    for (let i = 0; i < r; i++) {<br>        numerator *= (n - i);<br>        denominator *= (i + 1);<br>        <br>        // Simplificar durante el c√°lculo para evitar overflow<br>        const gcd = findGCD(numerator, denominator);<br>        numerator /= gcd;<br>        denominator /= gcd;<br>    }<br>    <br>    return numerator / denominator;<br>}<br>```<br><br><strong>Usando Tri√°ngulo de Pascal (DP):</strong><br>```javascript<br>function nCrDP(n, r) {<br>    if (r > n) return 0;<br>    <br>    const dp = Array(r + 1).fill(0);<br>    dp[0] = 1;<br>    <br>    for (let i = 1; i <= n; i++) {<br>        for (let j = Math.min(i, r); j > 0; j--) {<br>            dp[j] += dp[j - 1];<br>        }<br>    }<br>    <br>    return dp[r];<br>}<br>```<br><br><strong>L√≥gica:</strong> Usar la f√≥rmula optimizada o programaci√≥n din√°mica con el tri√°ngulo de Pascal."
      },
      {
        "id": "pascal-triangle",
        "title": "Pascal's Triangle",
        "type": "logic-problem",
        "content": "<strong>Problema:</strong> Generar las primeras n filas del tri√°ngulo de Pascal.<br><br><strong>Propiedades:</strong><br>‚Ä¢ Cada elemento es la suma de los dos elementos superiores<br>‚Ä¢ Fila n tiene n+1 elementos<br>‚Ä¢ Elemento en posici√≥n (n,r) = nCr<br><br><strong>Ejemplos:</strong><br>‚Ä¢ Input: n=4<br>‚Ä¢ Output: [[1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1]]<br><br><strong>Soluci√≥n Iterativa:</strong><br>```javascript<br>function generatePascalTriangle(numRows) {<br>    const triangle = [];<br>    <br>    for (let i = 0; i < numRows; i++) {<br>        const row = new Array(i + 1);<br>        row[0] = row[i] = 1; // Primero y √∫ltimo siempre son 1<br>        <br>        for (let j = 1; j < i; j++) {<br>            row[j] = triangle[i - 1][j - 1] + triangle[i - 1][j];<br>        }<br>        <br>        triangle.push(row);<br>    }<br>    <br>    return triangle;<br>}<br>```<br><br><strong>Obtener fila espec√≠fica:</strong><br>```javascript<br>function getPascalRow(rowIndex) {<br>    const row = new Array(rowIndex + 1);<br>    row[0] = 1;<br>    <br>    for (let i = 1; i <= rowIndex; i++) {<br>        row[i] = row[i - 1] * (rowIndex - i + 1) / i;<br>    }<br>    <br>    return row;<br>}<br>```<br><br><strong>Optimizaci√≥n de Espacio:</strong><br>```javascript<br>function getPascalRowOptimized(rowIndex) {<br>    let row = [1];<br>    <br>    for (let i = 1; i <= rowIndex; i++) {<br>        const newRow = new Array(i + 1);<br>        newRow[0] = newRow[i] = 1;<br>        <br>        for (let j = 1; j < i; j++) {<br>            newRow[j] = row[j - 1] + row[j];<br>        }<br>        <br>        row = newRow;<br>    }<br>    <br>    return row;<br>}<br>```<br><br><strong>Usando nCr:</strong><br>```javascript<br>function pascalTriangleUsingNCR(numRows) {<br>    const triangle = [];<br>    <br>    for (let n = 0; n < numRows; n++) {<br>        const row = [];<br>        for (let r = 0; r <= n; r++) {<br>            row.push(nCr(n, r));<br>        }<br>        triangle.push(row);<br>    }<br>    <br>    return triangle;<br>}<br>```<br><br><strong>L√≥gica:</strong> Cada elemento es la suma de los dos elementos de la fila anterior, o usar combinaciones nCr."
      },
      {
        "id": "all-factors",
        "title": "All Factors (Divisors) of a Number",
        "type": "logic-problem",
        "content": "<strong>Problema:</strong> Encontrar todos los divisores de un n√∫mero dado.<br><br><strong>Ejemplos:</strong><br>‚Ä¢ Input: 12, Output: [1, 2, 3, 4, 6, 12]<br>‚Ä¢ Input: 28, Output: [1, 2, 4, 7, 14, 28]<br><br><strong>Soluci√≥n B√°sica:</strong><br>```javascript<br>function getAllFactors(n) {<br>    const factors = [];<br>    for (let i = 1; i <= n; i++) {<br>        if (n % i === 0) {<br>            factors.push(i);<br>        }<br>    }<br>    return factors;<br>}<br>```<br><br><strong>Soluci√≥n Optimizada (O(‚àön)):</strong><br>```javascript<br>function getAllFactors(n) {<br>    const factors = [];<br>    const sqrt = Math.sqrt(n);<br>    <br>    for (let i = 1; i <= sqrt; i++) {<br>        if (n % i === 0) {<br>            factors.push(i);<br>            if (i !== n / i) { // Evitar duplicados para cuadrados perfectos<br>                factors.push(n / i);<br>            }<br>        }<br>    }<br>    <br>    return factors.sort((a, b) => a - b);<br>}<br>```<br><br><strong>Contar factores:</strong><br>```javascript<br>function countFactors(n) {<br>    let count = 0;<br>    const sqrt = Math.sqrt(n);<br>    <br>    for (let i = 1; i <= sqrt; i++) {<br>        if (n % i === 0) {<br>            count += (i === n / i) ? 1 : 2;<br>        }<br>    }<br>    <br>    return count;<br>}<br>```<br><br><strong>Factores primos √∫nicos:</strong><br>```javascript<br>function getPrimeFactors(n) {<br>    const primeFactors = [];<br>    <br>    // Dividir por 2<br>    while (n % 2 === 0) {<br>        primeFactors.push(2);<br>        n /= 2;<br>    }<br>    <br>    // Dividir por n√∫meros impares<br>    for (let i = 3; i <= Math.sqrt(n); i += 2) {<br>        while (n % i === 0) {<br>            primeFactors.push(i);<br>            n /= i;<br>        }<br>    }<br>    <br>    // Si n es primo mayor que 2<br>    if (n > 2) {<br>        primeFactors.push(n);<br>    }<br>    <br>    return primeFactors;<br>}<br>```<br><br><strong>L√≥gica:</strong> Iterar hasta la ra√≠z cuadrada y agregar tanto el divisor como su complemento."
      },
      {
        "id": "prime-factorization",
        "title": "Prime Factorization",
        "type": "logic-problem",
        "content": "<strong>Problema:</strong> Descomponer un n√∫mero en sus factores primos con sus exponentes.<br><br><strong>Ejemplos:</strong><br>‚Ä¢ Input: 60, Output: {2: 2, 3: 1, 5: 1} (60 = 2¬≤ √ó 3¬π √ó 5¬π)<br>‚Ä¢ Input: 100, Output: {2: 2, 5: 2} (100 = 2¬≤ √ó 5¬≤)<br><br><strong>Soluci√≥n Completa:</strong><br>```javascript<br>function primeFactorization(n) {<br>    const factors = {};<br>    <br>    // Factores de 2<br>    while (n % 2 === 0) {<br>        factors[2] = (factors[2] || 0) + 1;<br>        n /= 2;<br>    }<br>    <br>    // Factores impares<br>    for (let i = 3; i <= Math.sqrt(n); i += 2) {<br>        while (n % i === 0) {<br>            factors[i] = (factors[i] || 0) + 1;<br>            n /= i;<br>        }<br>    }<br>    <br>    // Si queda un n√∫mero primo mayor que ‚àön<br>    if (n > 2) {<br>        factors[n] = 1;<br>    }<br>    <br>    return factors;<br>}<br>```<br><br><strong>Como array de [factor, exponente]:</strong><br>```javascript<br>function primeFactorizationArray(n) {<br>    const factors = [];<br>    <br>    // Contar factores de 2<br>    let count = 0;<br>    while (n % 2 === 0) {<br>        count++;<br>        n /= 2;<br>    }<br>    if (count > 0) factors.push([2, count]);<br>    <br>    // Factores impares<br>    for (let i = 3; i <= Math.sqrt(n); i += 2) {<br>        count = 0;<br>        while (n % i === 0) {<br>            count++;<br>            n /= i;<br>        }<br>        if (count > 0) factors.push([i, count]);<br>    }<br>    <br>    if (n > 2) factors.push([n, 1]);<br>    <br>    return factors;<br>}<br>```<br><br><strong>Como string formateado:</strong><br>```javascript<br>function primeFactorizationString(n) {<br>    const factors = primeFactorization(n);<br>    return Object.entries(factors)<br>        .map(([prime, exp]) => exp === 1 ? prime : `${prime}^${exp}`)<br>        .join(' √ó ');<br>}<br>```<br><br><strong>Reconstruir n√∫mero:</strong><br>```javascript<br>function reconstructFromFactors(factors) {<br>    let result = 1;<br>    for (const [prime, exponent] of Object.entries(factors)) {<br>        result *= Math.pow(parseInt(prime), exponent);<br>    }<br>    return result;<br>}<br>```<br><br><strong>L√≥gica:</strong> Dividir repetidamente por factores primos y contar las veces que cada uno divide al n√∫mero."
      },
      {
        "id": "largest-prime-factor",
        "title": "Largest Prime Factor",
        "type": "logic-problem",
        "content": "<strong>Problema:</strong> Encontrar el factor primo m√°s grande de un n√∫mero.<br><br><strong>Ejemplos:</strong><br>‚Ä¢ Input: 60, Output: 5 (factores primos: 2, 3, 5)<br>‚Ä¢ Input: 13195, Output: 29 (factores: 5, 7, 13, 29)<br><br><strong>Soluci√≥n Eficiente:</strong><br>```javascript<br>function largestPrimeFactor(n) {<br>    let largest = -1;<br>    <br>    // Eliminar factores de 2<br>    while (n % 2 === 0) {<br>        largest = 2;<br>        n /= 2;<br>    }<br>    <br>    // Verificar factores impares<br>    for (let i = 3; i <= Math.sqrt(n); i += 2) {<br>        while (n % i === 0) {<br>            largest = i;<br>            n /= i;<br>        }<br>    }<br>    <br>    // Si n es un primo mayor que 2<br>    if (n > 2) {<br>        largest = n;<br>    }<br>    <br>    return largest;<br>}<br>```<br><br><strong>Versi√≥n Optimizada para N√∫meros Grandes:</strong><br>```javascript<br>function largestPrimeFactorOptimized(n) {<br>    if (n <= 1) return -1;<br>    if (n === 2) return 2;<br>    <br>    let largest = -1;<br>    <br>    // Eliminar todos los factores de 2<br>    if (n % 2 === 0) {<br>        largest = 2;<br>        while (n % 2 === 0) {<br>            n /= 2;<br>        }<br>    }<br>    <br>    // Verificar factores impares hasta ‚àön<br>    for (let i = 3; i * i <= n; i += 2) {<br>        if (n % i === 0) {<br>            largest = i;<br>            while (n % i === 0) {<br>                n /= i;<br>            }<br>        }<br>    }<br>    <br>    // Si n > 1, entonces n es primo<br>    if (n > 1) {<br>        largest = n;<br>    }<br>    <br>    return largest;<br>}<br>```<br><br><strong>Con lista de primos precomputados:</strong><br>```javascript<br>function sieveOfEratosthenes(limit) {<br>    const primes = [];<br>    const isPrime = Array(limit + 1).fill(true);<br>    isPrime[0] = isPrime[1] = false;<br>    <br>    for (let i = 2; i <= limit; i++) {<br>        if (isPrime[i]) {<br>            primes.push(i);<br>            for (let j = i * i; j <= limit; j += i) {<br>                isPrime[j] = false;<br>            }<br>        }<br>    }<br>    return primes;<br>}<br><br>function largestPrimeFactorUsingSieve(n) {<br>    const primes = sieveOfEratosthenes(Math.sqrt(n));<br>    let largest = -1;<br>    <br>    for (const prime of primes) {<br>        if (prime * prime > n) break;<br>        <br>        if (n % prime === 0) {<br>            largest = prime;<br>            while (n % prime === 0) {<br>                n /= prime;<br>            }<br>        }<br>    }<br>    <br>    if (n > 1) largest = n;<br>    return largest;<br>}<br>```<br><br><strong>L√≥gica:</strong> Factorizar el n√∫mero y mantener registro del factor primo m√°s grande encontrado."
      },
      {
        "id": "modular-exponentiation",
        "title": "Modular Exponentiation",
        "type": "logic-problem",
        "content": "<strong>Problema:</strong> Calcular (base^exp) % mod eficientemente para n√∫meros grandes.<br><br><strong>Ejemplos:</strong><br>‚Ä¢ Input: base=2, exp=10, mod=1000, Output: 24 (2^10 = 1024, 1024 % 1000 = 24)<br>‚Ä¢ Input: base=3, exp=5, mod=7, Output: 5 (3^5 = 243, 243 % 7 = 5)<br><br><strong>Exponenciaci√≥n R√°pida:</strong><br>```javascript<br>function modularExponentiation(base, exp, mod) {<br>    if (mod === 1) return 0;<br>    <br>    let result = 1;<br>    base = base % mod;<br>    <br>    while (exp > 0) {<br>        // Si exp es impar, multiplicar base con result<br>        if (exp % 2 === 1) {<br>            result = (result * base) % mod;<br>        }<br>        <br>        // exp debe ser par ahora<br>        exp = Math.floor(exp / 2);<br>        base = (base * base) % mod;<br>    }<br>    <br>    return result;<br>}<br>```<br><br><strong>Versi√≥n Recursiva:</strong><br>```javascript<br>function modPowerRecursive(base, exp, mod) {<br>    if (exp === 0) return 1;<br>    if (exp === 1) return base % mod;<br>    <br>    if (exp % 2 === 0) {<br>        const half = modPowerRecursive(base, exp / 2, mod);<br>        return (half * half) % mod;<br>    } else {<br>        return (base * modPowerRecursive(base, exp - 1, mod)) % mod;<br>    }<br>}<br>```<br><br><strong>Con BigInt para n√∫meros muy grandes:</strong><br>```javascript<br>function modularExponentiationBig(base, exp, mod) {<br>    if (mod === 1n) return 0n;<br>    <br>    let result = 1n;<br>    base = base % mod;<br>    <br>    while (exp > 0n) {<br>        if (exp % 2n === 1n) {<br>            result = (result * base) % mod;<br>        }<br>        exp = exp / 2n;<br>        base = (base * base) % mod;<br>    }<br>    <br>    return result;<br>}<br>```<br><br><strong>Verificar Fermat's Little Theorem:</strong><br>```javascript<br>function fermatTest(p) {<br>    // Si p es primo, entonces a^(p-1) ‚â° 1 (mod p) para cualquier a no divisible por p<br>    const a = 2; // Base de prueba<br>    return modularExponentiation(a, p - 1, p) === 1;<br>}<br>```<br><br><strong>L√≥gica:</strong> Usar exponenciaci√≥n binaria para reducir la complejidad de O(exp) a O(log exp)."
      },
      {
        "id": "catalan-number",
        "title": "nth Catalan Number",
        "type": "logic-problem",
        "content": "<strong>Problema:</strong> Calcular el en√©simo n√∫mero de Catalan.<br><br><strong>F√≥rmula:</strong> C(n) = (2n)! / ((n+1)! √ó n!) = (1/(n+1)) √ó C(2n, n)<br><br><strong>Ejemplos:</strong><br>‚Ä¢ Input: n=0, Output: 1<br>‚Ä¢ Input: n=3, Output: 5<br>‚Ä¢ Secuencia: 1, 1, 2, 5, 14, 42, 132...<br><br><strong>Usando nCr:</strong><br>```javascript<br>function nCr(n, r) {<br>    if (r > n - r) r = n - r; // Optimizaci√≥n<br>    let result = 1;<br>    for (let i = 0; i < r; i++) {<br>        result = result * (n - i) / (i + 1);<br>    }<br>    return Math.round(result);<br>}<br><br>function catalanNumber(n) {<br>    if (n <= 1) return 1;<br>    return nCr(2 * n, n) / (n + 1);<br>}<br>```<br><br><strong>Programaci√≥n Din√°mica:</strong><br>```javascript<br>function catalanNumber(n) {<br>    if (n <= 1) return 1;<br>    <br>    const catalan = new Array(n + 1);<br>    catalan[0] = catalan[1] = 1;<br>    <br>    for (let i = 2; i <= n; i++) {<br>        catalan[i] = 0;<br>        for (let j = 0; j < i; j++) {<br>            catalan[i] += catalan[j] * catalan[i - 1 - j];<br>        }<br>    }<br>    <br>    return catalan[n];<br>}<br>```<br><br><strong>F√≥rmula Recursiva:</strong><br>```javascript<br>function catalanRecursive(n, memo = {}) {<br>    if (n <= 1) return 1;<br>    if (n in memo) return memo[n];<br>    <br>    let result = 0;<br>    for (let i = 0; i < n; i++) {<br>        result += catalanRecursive(i, memo) * catalanRecursive(n - 1 - i, memo);<br>    }<br>    <br>    memo[n] = result;<br>    return result;<br>}<br>```<br><br><strong>Generar secuencia:</strong><br>```javascript<br>function generateCatalanSequence(count) {<br>    const sequence = [1]; // C(0) = 1<br>    <br>    for (let n = 1; n < count; n++) {<br>        let catalan = 0;<br>        for (let i = 0; i < n; i++) {<br>            catalan += sequence[i] * sequence[n - 1 - i];<br>        }<br>        sequence.push(catalan);<br>    }<br>    <br>    return sequence;<br>}<br>```<br><br><strong>Aplicaciones:</strong><br>```javascript<br>// N√∫mero de BSTs diferentes con n nodos<br>function countBSTs(n) {<br>    return catalanNumber(n);<br>}<br><br>// Formas de parentizar n+1 factores<br>function countParenthesizations(n) {<br>    return catalanNumber(n);<br>}<br>```<br><br><strong>L√≥gica:</strong> Los n√∫meros de Catalan aparecen en muchos problemas combinatorios y se pueden calcular usando DP o la f√≥rmula directa."
      },
      {
        "id": "binomial-coefficient",
        "title": "Binomial Coefficient with Large Numbers",
        "type": "logic-problem",
        "content": "<strong>Problema:</strong> Calcular coeficientes binomiales C(n,k) para n√∫meros grandes sin overflow.<br><br><strong>Ejemplos:</strong><br>‚Ä¢ Input: n=50, k=25, Output: 126410606437752<br>‚Ä¢ Input: n=100, k=50, Output: n√∫mero muy grande<br><br><strong>M√©todo Optimizado:</strong><br>```javascript<br>function binomialCoefficient(n, k) {<br>    if (k > n - k) k = n - k; // Usar simetr√≠a C(n,k) = C(n,n-k)<br>    if (k === 0 || k === n) return 1;<br>    <br>    let result = 1;<br>    <br>    for (let i = 0; i < k; i++) {<br>        result = Math.floor(result * (n - i) / (i + 1));<br>    }<br>    <br>    return result;<br>}<br>```<br><br><strong>Con BigInt para n√∫meros muy grandes:</strong><br>```javascript<br>function binomialCoefficientBig(n, k) {<br>    n = BigInt(n);<br>    k = BigInt(k);<br>    <br>    if (k > n - k) k = n - k;<br>    if (k === 0n || k === n) return 1n;<br>    <br>    let result = 1n;<br>    <br>    for (let i = 0n; i < k; i++) {<br>        result = result * (n - i) / (i + 1n);<br>    }<br>    <br>    return result;<br>}<br>```<br><br><strong>Usando Pascal's Triangle (DP):</strong><br>```javascript<br>function binomialCoefficientDP(n, k) {<br>    if (k > n) return 0;<br>    if (k === 0 || k === n) return 1;<br>    <br>    // Solo necesitamos la fila anterior<br>    let prev = new Array(k + 1).fill(0);<br>    prev[0] = 1;<br>    <br>    for (let i = 1; i <= n; i++) {<br>        const curr = new Array(Math.min(i, k) + 1).fill(0);<br>        curr[0] = 1;<br>        <br>        for (let j = 1; j <= Math.min(i, k); j++) {<br>            curr[j] = (prev[j - 1] || 0) + (prev[j] || 0);<br>        }<br>        <br>        prev = curr;<br>    }<br>    <br>    return prev[k] || 0;<br>}<br>```<br><br><strong>M√©todo Modular (para resultados muy grandes):</strong><br>```javascript<br>function binomialCoefficientMod(n, k, mod) {<br>    if (k > n) return 0;<br>    if (k === 0 || k === n) return 1;<br>    <br>    k = Math.min(k, n - k);<br>    <br>    let numerator = 1, denominator = 1;<br>    <br>    for (let i = 0; i < k; i++) {<br>        numerator = (numerator * ((n - i) % mod)) % mod;<br>        denominator = (denominator * (i + 1)) % mod;<br>    }<br>    <br>    // Calcular inverso modular de denominator<br>    function modInverse(a, m) {<br>        return modularExponentiation(a, m - 2, m); // Cuando m es primo<br>    }<br>    <br>    return (numerator * modInverse(denominator, mod)) % mod;<br>}<br>```<br><br><strong>Propiedades √∫tiles:</strong><br>```javascript<br>// Verificar identidad: C(n,k) = C(n-1,k-1) + C(n-1,k)<br>function verifyPascalIdentity(n, k) {<br>    if (k === 0 || k === n) return true;<br>    <br>    const left = binomialCoefficient(n, k);<br>    const right = binomialCoefficient(n - 1, k - 1) + binomialCoefficient(n - 1, k);<br>    <br>    return left === right;<br>}<br>```<br><br><strong>L√≥gica:</strong> Usar propiedades matem√°ticas y optimizaciones para evitar overflow en n√∫meros grandes."
      }
    ]
  }
}
