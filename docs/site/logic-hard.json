{
  "title": "Logic Building Problems - Dif√≠cil",
  "description": "Problemas avanzados de construcci√≥n de l√≥gica de programaci√≥n",
  "version": "1.0",
  "lastUpdated": "2025-08-21",
  "difficulty": "hard",
  "section": {
    "id": "logic-hard",
    "title": "üî¥ Logic Building - Problemas Dif√≠ciles",
    "description": "Problemas de nivel avanzado para dominar la l√≥gica de programaci√≥n",
    "subsections": [
      {
        "id": "sieve-eratosthenes",
        "title": "Sieve of Eratosthenes",
        "type": "logic-problem",
        "content": "<strong>Problema:</strong> Encontrar todos los n√∫meros primos hasta n usando el algoritmo de la Criba de Erat√≥stenes.<br><br><strong>Ejemplos:</strong><br>‚Ä¢ Input: n=30, Output: [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]<br>‚Ä¢ Input: n=10, Output: [2, 3, 5, 7]<br><br><strong>Implementaci√≥n Cl√°sica:</strong><br>```javascript<br>function sieveOfEratosthenes(n) {<br>    const primes = [];<br>    const isPrime = Array(n + 1).fill(true);<br>    isPrime[0] = isPrime[1] = false;<br>    <br>    for (let i = 2; i <= n; i++) {<br>        if (isPrime[i]) {<br>            primes.push(i);<br>            // Marcar m√∫ltiplos como no primos<br>            for (let j = i * i; j <= n; j += i) {<br>                isPrime[j] = false;<br>            }<br>        }<br>    }<br>    <br>    return primes;<br>}<br>```<br><br><strong>Versi√≥n Optimizada:</strong><br>```javascript<br>function sieveOptimized(n) {<br>    if (n < 2) return [];<br>    <br>    const primes = [2];<br>    const isPrime = Array(n + 1).fill(true);<br>    <br>    // Solo verificar n√∫meros impares<br>    for (let i = 3; i <= n; i += 2) {<br>        if (isPrime[i]) {<br>            primes.push(i);<br>            // Marcar m√∫ltiplos impares solamente<br>            for (let j = i * i; j <= n; j += 2 * i) {<br>                isPrime[j] = false;<br>            }<br>        }<br>    }<br>    <br>    return primes;<br>}<br>```<br><br><strong>Criba Segmentada (para n√∫meros muy grandes):</strong><br>```javascript<br>function segmentedSieve(n) {<br>    const limit = Math.floor(Math.sqrt(n)) + 1;<br>    const basePrimes = sieveOfEratosthenes(limit);<br>    <br>    const result = [...basePrimes.filter(p => p <= n)];<br>    const segmentSize = Math.max(limit, 32768);<br>    <br>    for (let low = limit; low <= n; low += segmentSize) {<br>        const high = Math.min(low + segmentSize - 1, n);<br>        const isPrime = Array(high - low + 1).fill(true);<br>        <br>        for (const prime of basePrimes) {<br>            const start = Math.max(prime * prime, Math.ceil(low / prime) * prime);<br>            for (let j = start; j <= high; j += prime) {<br>                isPrime[j - low] = false;<br>            }<br>        }<br>        <br>        for (let i = 0; i < isPrime.length; i++) {<br>            if (isPrime[i]) {<br>                result.push(low + i);<br>            }<br>        }<br>    }<br>    <br>    return result;<br>}<br>```<br><br><strong>L√≥gica:</strong> Eliminar sistem√°ticamente m√∫ltiplos de cada primo encontrado."
      },
      {
        "id": "clock-angle",
        "title": "Clock Angle Problem",
        "type": "logic-problem",
        "content": "<strong>Problema:</strong> Calcular el √°ngulo entre las manecillas del reloj a una hora dada.<br><br><strong>Ejemplos:</strong><br>‚Ä¢ Input: 3:00, Output: 90¬∞ (√°ngulo recto)<br>‚Ä¢ Input: 6:00, Output: 180¬∞ (l√≠nea recta)<br>‚Ä¢ Input: 3:30, Output: 105¬∞<br><br><strong>F√≥rmulas:</strong><br>‚Ä¢ Minutero: 6¬∞ por minuto (360¬∞/60min)<br>‚Ä¢ Horario: 30¬∞ por hora + 0.5¬∞ por minuto (360¬∞/12h)<br><br><strong>Soluci√≥n Completa:</strong><br>```javascript<br>function clockAngle(hours, minutes) {<br>    // Normalizar horas a formato 12h<br>    hours = hours % 12;<br>    <br>    // Calcular √°ngulos desde las 12<br>    const minuteAngle = minutes * 6;<br>    const hourAngle = hours * 30 + minutes * 0.5;<br>    <br>    // Diferencia absoluta<br>    let angle = Math.abs(hourAngle - minuteAngle);<br>    <br>    // Tomar el √°ngulo menor (‚â§ 180¬∞)<br>    return Math.min(angle, 360 - angle);<br>}<br>```<br><br><strong>Versi√≥n con Segundos:</strong><br>```javascript<br>function clockAngleWithSeconds(hours, minutes, seconds) {<br>    hours = hours % 12;<br>    <br>    // √Ångulo del segundero: 6¬∞ por segundo<br>    const secondAngle = seconds * 6;<br>    <br>    // √Ångulo del minutero: 6¬∞ por minuto + 0.1¬∞ por segundo<br>    const minuteAngle = minutes * 6 + seconds * 0.1;<br>    <br>    // √Ångulo del horario: 30¬∞ por hora + 0.5¬∞ por minuto + 0.00833¬∞ por segundo<br>    const hourAngle = hours * 30 + minutes * 0.5 + seconds * (0.5 / 60);<br>    <br>    function getMinAngle(angle1, angle2) {<br>        let diff = Math.abs(angle1 - angle2);<br>        return Math.min(diff, 360 - diff);<br>    }<br>    <br>    return {<br>        hourMinute: getMinAngle(hourAngle, minuteAngle),<br>        hourSecond: getMinAngle(hourAngle, secondAngle),<br>        minuteSecond: getMinAngle(minuteAngle, secondAngle)<br>    };<br>}<br>```<br><br><strong>Encontrar tiempos con √°ngulos espec√≠ficos:</strong><br>```javascript<br>function findTimesWithAngle(targetAngle) {<br>    const times = [];<br>    <br>    for (let h = 0; h < 12; h++) {<br>        for (let m = 0; m < 60; m++) {<br>            if (Math.abs(clockAngle(h, m) - targetAngle) < 0.1) {<br>                times.push(`${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}`);<br>            }<br>        }<br>    }<br>    <br>    return times;<br>}<br>```<br><br><strong>Cu√°ntas veces se superponen las manecillas:</strong><br>```javascript<br>function clockOverlaps() {<br>    const overlaps = [];<br>    <br>    // Las manecillas se superponen 11 veces en 12 horas<br>    for (let i = 0; i < 11; i++) {<br>        const minutes = (720 * i) / 11; // 720 = 12 * 60<br>        const h = Math.floor(minutes / 60);<br>        const m = minutes % 60;<br>        <br>        overlaps.push({<br>            hour: h,<br>            minute: m,<br>            time: `${h}:${m.toFixed(2).padStart(5, '0')}`<br>        });<br>    }<br>    <br>    return overlaps;<br>}<br>```<br><br><strong>L√≥gica:</strong> Aplicar las velocidades angulares de cada manecilla y calcular diferencias."
      },
      {
        "id": "tower-hanoi",
        "title": "Tower of Hanoi",
        "type": "logic-problem",
        "content": "<strong>Problema:</strong> Resolver el puzzle de las Torres de Hanoi para n discos.<br><br><strong>Reglas:</strong><br>‚Ä¢ Solo se puede mover un disco a la vez<br>‚Ä¢ Un disco m√°s grande no puede estar sobre uno m√°s peque√±o<br>‚Ä¢ Mover todos los discos de la torre origen a la destino<br><br><strong>Ejemplos:</strong><br>‚Ä¢ n=1: 1 movimiento<br>‚Ä¢ n=2: 3 movimientos<br>‚Ä¢ n=3: 7 movimientos (2^n - 1)<br><br><strong>Soluci√≥n Recursiva:</strong><br>```javascript<br>function towerOfHanoi(n, source, destination, auxiliary) {<br>    const moves = [];<br>    <br>    function solve(disks, from, to, temp) {<br>        if (disks === 1) {<br>            moves.push(`Move disk 1 from ${from} to ${to}`);<br>            return;<br>        }<br>        <br>        // Mover n-1 discos al auxiliar<br>        solve(disks - 1, from, temp, to);<br>        <br>        // Mover el disco m√°s grande al destino<br>        moves.push(`Move disk ${disks} from ${from} to ${to}`);<br>        <br>        // Mover n-1 discos del auxiliar al destino<br>        solve(disks - 1, temp, to, from);<br>    }<br>    <br>    solve(n, source, destination, auxiliary);<br>    return moves;<br>}<br>```<br><br><strong>Soluci√≥n Iterativa:</strong><br>```javascript<br>function towerOfHanoiIterative(n) {<br>    const totalMoves = Math.pow(2, n) - 1;<br>    const moves = [];<br>    <br>    // Torres: 0=source, 1=auxiliary, 2=destination<br>    const towers = [[], [], []];<br>    <br>    // Inicializar torre source<br>    for (let i = n; i >= 1; i--) {<br>        towers[0].push(i);<br>    }<br>    <br>    // Determinar direcci√≥n basada en paridad de n<br>    const direction = n % 2 === 0 ? [0, 1, 2] : [0, 2, 1];<br>    <br>    for (let i = 1; i <= totalMoves; i++) {<br>        const fromTower = (i & (i - 1)) % 3;<br>        const toTower = ((i | (i - 1)) + 1) % 3;<br>        <br>        const disk = towers[fromTower].pop();<br>        towers[toTower].push(disk);<br>        <br>        moves.push(`Move disk ${disk} from tower ${fromTower} to tower ${toTower}`);<br>    }<br>    <br>    return moves;<br>}<br>```<br><br><strong>Visualizaci√≥n del Estado:</strong><br>```javascript<br>class HanoiGame {<br>    constructor(n) {<br>        this.n = n;<br>        this.towers = [[], [], []];<br>        this.moves = 0;<br>        <br>        // Inicializar torre A<br>        for (let i = n; i >= 1; i--) {<br>            this.towers[0].push(i);<br>        }<br>    }<br>    <br>    moveDisk(from, to) {<br>        if (this.towers[from].length === 0) {<br>            throw new Error('No disk to move from tower ' + from);<br>        }<br>        <br>        const disk = this.towers[from][this.towers[from].length - 1];<br>        const topDestination = this.towers[to][this.towers[to].length - 1];<br>        <br>        if (topDestination && disk > topDestination) {<br>            throw new Error('Cannot place larger disk on smaller disk');<br>        }<br>        <br>        this.towers[to].push(this.towers[from].pop());<br>        this.moves++;<br>        <br>        return this.isComplete();<br>    }<br>    <br>    isComplete() {<br>        return this.towers[2].length === this.n;<br>    }<br>    <br>    display() {<br>        console.log('Tower A:', this.towers[0]);<br>        console.log('Tower B:', this.towers[1]);<br>        console.log('Tower C:', this.towers[2]);<br>        console.log('Moves:', this.moves);<br>    }<br>}<br>```<br><br><strong>C√°lculo de Complejidad:</strong><br>```javascript<br>function hanoiComplexity(n) {<br>    return {<br>        moves: Math.pow(2, n) - 1,<br>        timeComplexity: 'O(2^n)',<br>        spaceComplexity: 'O(n)', // por la pila de recursi√≥n<br>        formula: '2^n - 1'<br>    };<br>}<br>```<br><br><strong>L√≥gica:</strong> Dividir el problema recursivamente: mover n-1 discos, mover el disco grande, mover n-1 discos."
      },
      {
        "id": "rat-poisoned",
        "title": "Rat and Poisoned Bottles Problem",
        "type": "logic-problem",
        "content": "<strong>Problema:</strong> Determinar cu√°l de 1000 botellas est√° envenenada usando el menor n√∫mero de ratas en 24 horas.<br><br><strong>Restricciones:</strong><br>‚Ä¢ Solo tienes ratas de laboratorio<br>‚Ä¢ El veneno mata en exactamente 24 horas<br>‚Ä¢ Necesitas identificar exactamente cu√°l botella est√° envenenada<br><br><strong>Soluci√≥n √ìptima:</strong><br>```javascript<br>function ratPoisonSolution(bottles = 1000) {<br>    // Necesitamos log‚ÇÇ(bottles) ratas redondeado hacia arriba<br>    const ratsNeeded = Math.ceil(Math.log2(bottles));<br>    <br>    console.log(`Para ${bottles} botellas necesitas ${ratsNeeded} ratas`);<br>    <br>    // Estrategia de codificaci√≥n binaria<br>    function createTestingPlan(totalBottles, rats) {<br>        const plan = [];<br>        <br>        for (let rat = 0; rat < rats; rat++) {<br>            const bottlesToTest = [];<br>            <br>            for (let bottle = 1; bottle <= totalBottles; bottle++) {<br>                // Si el bit 'rat' est√° activado en el n√∫mero de botella<br>                if (bottle & (1 << rat)) {<br>                    bottlesToTest.push(bottle);<br>                }<br>            }<br>            <br>            plan.push({<br>                rat: rat + 1,<br>                bottles: bottlesToTest,<br>                binaryPosition: rat<br>            });<br>        }<br>        <br>        return plan;<br>    }<br>    <br>    return {\r>        ratsNeeded,<br>        testingPlan: createTestingPlan(bottles, ratsNeeded),<br>        explanation: 'Cada rata representa un bit. Las ratas que mueran indican qu√© bits est√°n activados en el n√∫mero de la botella envenenada.'<br>    };<br>}<br>```<br><br><strong>Decodificar Resultados:</strong><br>```javascript<br>function decodePoisonedBottle(deadRats) {<br>    // deadRats es un array de n√∫meros de ratas que murieron<br>    let bottleNumber = 0;<br>    <br>    for (const rat of deadRats) {<br>        // rat-1 porque las ratas est√°n numeradas desde 1<br>        bottleNumber |= (1 << (rat - 1));<br>    }<br>    <br>    return bottleNumber || 'Ninguna rata muri√≥ - la botella 0 o ninguna est√° envenenada';<br>}<br>```<br><br><strong>Simulaci√≥n Completa:</strong><br>```javascript<br>class PoisonBottleSimulation {<br>    constructor(totalBottles = 1000) {<br>        this.totalBottles = totalBottles;<br>        this.ratsNeeded = Math.ceil(Math.log2(totalBottles));<br>        this.poisonedBottle = Math.floor(Math.random() * totalBottles) + 1;<br>        this.testingPlan = this.createPlan();<br>    }<br>    <br>    createPlan() {<br>        const plan = new Map();<br>        <br>        for (let rat = 1; rat <= this.ratsNeeded; rat++) {<br>            const bottles = [];<br>            for (let bottle = 1; bottle <= this.totalBottles; bottle++) {<br>                if (bottle & (1 << (rat - 1))) {<br>                    bottles.push(bottle);<br>                }<br>            }<br>            plan.set(rat, bottles);<br>        }<br>        <br>        return plan;<br>    }<br>    <br>    runExperiment() {<br>        const deadRats = [];<br>        <br>        for (const [rat, bottles] of this.testingPlan) {<br>            if (bottles.includes(this.poisonedBottle)) {<br>                deadRats.push(rat);<br>            }<br>        }<br>        <br>        const detectedBottle = decodePoisonedBottle(deadRats);<br>        <br>        return {<br>            actualPoisonedBottle: this.poisonedBottle,<br>            detectedBottle,<br>            deadRats,<br>            success: detectedBottle === this.poisonedBottle,<br>            ratsUsed: this.ratsNeeded<br>        };<br>    }<br>}<br>```<br><br><strong>Variantes del Problema:</strong><br>```javascript<br>// ¬øQu√© pasa si hay m√∫ltiples botellas envenenadas?<br>function multiplePoisons(bottles, maxPoisons) {<br>    // Para k botellas envenenadas necesitamos m√°s ratas<br>    // Este es un problema de c√≥digos correctores de errores<br>    const ratsNeeded = Math.ceil(Math.log2(combinations(bottles, maxPoisons)));<br>    return ratsNeeded;<br>}<br><br>// ¬øQu√© pasa si el veneno tarda d√≠as diferentes?<br>function variableDelay(bottles, possibleDelays) {<br>    // Podemos usar el tiempo como dimensi√≥n adicional<br>    const timeBits = Math.ceil(Math.log2(possibleDelays.length));<br>    const bottleBits = Math.ceil(Math.log2(bottles));<br>    return bottleBits; // El tiempo nos da informaci√≥n extra gratis<br>}<br>```<br><br><strong>L√≥gica:</strong> Usar representaci√≥n binaria donde cada rata representa un bit del n√∫mero de botella."
      },
      {
        "id": "eight-puzzle",
        "title": "8-Puzzle Problem",
        "type": "logic-problem",
        "content": "<strong>Problema:</strong> Resolver el puzzle deslizante 8-puzzle usando algoritmos de b√∫squeda.<br><br><strong>Estado Inicial:</strong> Matriz 3x3 con n√∫meros 1-8 y un espacio vac√≠o<br><strong>Estado Final:</strong> N√∫meros ordenados con el espacio en la esquina<br><br><strong>Ejemplo:</strong><br>```<br>Inicial:    Final:<br>1 2 3       1 2 3<br>4   6  -->  4 5 6<br>7 5 8       7 8  <br>```<br><br><strong>Representaci√≥n del Estado:</strong><br>```javascript<br>class PuzzleState {<br>    constructor(board, moves = 0, parent = null) {<br>        this.board = board; // Array 1D de 9 elementos<br>        this.moves = moves;<br>        this.parent = parent;<br>        this.blankPos = board.indexOf(0); // 0 representa espacio vac√≠o<br>    }<br>    <br>    toString() {<br>        return this.board.join(',');<br>    }<br>    <br>    isGoal() {<br>        const goal = [1, 2, 3, 4, 5, 6, 7, 8, 0];<br>        return this.board.every((val, idx) => val === goal[idx]);<br>    }<br>    <br>    getNeighbors() {<br>        const neighbors = [];<br>        const row = Math.floor(this.blankPos / 3);<br>        const col = this.blankPos % 3;<br>        <br>        // Movimientos posibles: arriba, abajo, izquierda, derecha<br>        const moves = [<br>            [-1, 0], [1, 0], [0, -1], [0, 1]<br>        ];<br>        <br>        for (const [dr, dc] of moves) {<br>            const newRow = row + dr;<br>            const newCol = col + dc;<br>            <br>            if (newRow >= 0 && newRow < 3 && newCol >= 0 && newCol < 3) {<br>                const newPos = newRow * 3 + newCol;<br>                const newBoard = [...this.board];<br>                <br>                // Intercambiar espacio vac√≠o con la pieza<br>                [newBoard[this.blankPos], newBoard[newPos]] = <br>                [newBoard[newPos], newBoard[this.blankPos]];<br>                <br>                neighbors.push(new PuzzleState(newBoard, this.moves + 1, this));<br>            }<br>        }<br>        <br>        return neighbors;<br>    }<br>}<br>```<br><br><strong>Algoritmo A* con Heur√≠stica Manhattan:</strong><br>```javascript<br>function manhattanDistance(board) {<br>    let distance = 0;<br>    <br>    for (let i = 0; i < 9; i++) {<br>        if (board[i] !== 0) {<br>            const value = board[i];<br>            const targetPos = value - 1; // Posici√≥n objetivo (0-indexada)<br>            const currentRow = Math.floor(i / 3);<br>            const currentCol = i % 3;<br>            const targetRow = Math.floor(targetPos / 3);<br>            const targetCol = targetPos % 3;<br>            <br>            distance += Math.abs(currentRow - targetRow) + Math.abs(currentCol - targetCol);<br>        }<br>    }<br>    <br>    return distance;<br>}<br><br>function solvePuzzleAStar(initialBoard) {<br>    const start = new PuzzleState(initialBoard);<br>    <br>    if (start.isGoal()) return [start];<br>    <br>    const openSet = [start];<br>    const closedSet = new Set();<br>    const gScore = new Map(); // Costo real desde el inicio<br>    const fScore = new Map(); // gScore + heur√≠stica<br>    <br>    gScore.set(start.toString(), 0);<br>    fScore.set(start.toString(), manhattanDistance(start.board));<br>    <br>    while (openSet.length > 0) {<br>        // Encontrar el nodo con menor fScore<br>        openSet.sort((a, b) => <br>            fScore.get(a.toString()) - fScore.get(b.toString()));<br>        <br>        const current = openSet.shift();<br>        const currentKey = current.toString();<br>        <br>        if (current.isGoal()) {<br>            // Reconstruir camino<br>            const path = [];<br>            let node = current;<br>            while (node) {<br>                path.unshift(node);<br>                node = node.parent;<br>            }<br>            return path;<br>        }<br>        <br>        closedSet.add(currentKey);<br>        <br>        for (const neighbor of current.getNeighbors()) {<br>            const neighborKey = neighbor.toString();<br>            <br>            if (closedSet.has(neighborKey)) continue;<br>            <br>            const tentativeG = gScore.get(currentKey) + 1;<br>            <br>            if (!gScore.has(neighborKey) || tentativeG < gScore.get(neighborKey)) {<br>                gScore.set(neighborKey, tentativeG);<br>                fScore.set(neighborKey, tentativeG + manhattanDistance(neighbor.board));<br>                neighbor.parent = current;<br>                <br>                if (!openSet.some(state => state.toString() === neighborKey)) {<br>                    openSet.push(neighbor);<br>                }<br>            }<br>        }<br>    }<br>    <br>    return null; // No solution found<br>}<br>```<br><br><strong>Verificar si el Puzzle es Solucionable:</strong><br>```javascript<br>function isSolvable(board) {<br>    // Contar inversiones (pares de n√∫meros fuera de orden)<br>    let inversions = 0;<br>    const flatBoard = board.filter(x => x !== 0); // Remover espacio vac√≠o<br>    <br>    for (let i = 0; i < flatBoard.length; i++) {<br>        for (let j = i + 1; j < flatBoard.length; j++) {<br>            if (flatBoard[i] > flatBoard[j]) {<br>                inversions++;<br>            }<br>        }<br>    }<br>    <br>    // Para 8-puzzle, es solucionable si las inversiones son pares<br>    return inversions % 2 === 0;<br>}<br>```<br><br><strong>Generador de Puzzles Aleatorios:</strong><br>```javascript<br>function generateRandomPuzzle() {<br>    let board;<br>    <br>    do {<br>        board = [0, 1, 2, 3, 4, 5, 6, 7, 8];<br>        <br>        // Mezclar usando algoritmo Fisher-Yates<br>        for (let i = board.length - 1; i > 0; i--) {<br>            const j = Math.floor(Math.random() * (i + 1));<br>            [board[i], board[j]] = [board[j], board[i]];<br>        }<br>    } while (!isSolvable(board));<br>    <br>    return board;<br>}<br>```<br><br><strong>L√≥gica:</strong> Usar b√∫squeda informada con heur√≠stica de distancia Manhattan para encontrar la soluci√≥n √≥ptima."
      },
      {
        "id": "matrix-determinant",
        "title": "Determinant of a Matrix",
        "type": "logic-problem",
        "content": "<strong>Problema:</strong> Calcular el determinante de una matriz cuadrada de cualquier tama√±o.<br><br><strong>Casos Base:</strong><br>‚Ä¢ 1x1: det([a]) = a<br>‚Ä¢ 2x2: det([[a,b],[c,d]]) = ad - bc<br>‚Ä¢ 3x3: Regla de Sarrus o expansi√≥n por cofactores<br><br><strong>Ejemplos:</strong><br>```<br>Matrix 2x2:     Matrix 3x3:<br>[1 2]           [1 2 3]<br>[3 4]  = -2     [4 5 6] = 0<br>                [7 8 9]<br>```<br><br><strong>Soluci√≥n Recursiva (Expansi√≥n por Cofactores):</strong><br>```javascript<br>function determinant(matrix) {<br>    const n = matrix.length;<br>    <br>    // Verificar que sea matriz cuadrada<br>    if (!matrix.every(row => row.length === n)) {<br>        throw new Error('Matrix must be square');<br>    }<br>    <br>    // Caso base: matriz 1x1<br>    if (n === 1) {<br>        return matrix[0][0];<br>    }<br>    <br>    // Caso base: matriz 2x2<br>    if (n === 2) {<br>        return matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0];<br>    }<br>    <br>    // Expansi√≥n por la primera fila<br>    let det = 0;<br>    for (let col = 0; col < n; col++) {<br>        const sign = col % 2 === 0 ? 1 : -1;<br>        const subMatrix = getSubMatrix(matrix, 0, col);<br>        det += sign * matrix[0][col] * determinant(subMatrix);<br>    }<br>    <br>    return det;<br>}<br><br>function getSubMatrix(matrix, excludeRow, excludeCol) {<br>    return matrix<br>        .filter((_, rowIndex) => rowIndex !== excludeRow)<br>        .map(row => row.filter((_, colIndex) => colIndex !== excludeCol));<br>}<br>```<br><br><strong>M√©todo de Eliminaci√≥n Gaussiana (M√°s Eficiente):</strong><br>```javascript<br>function determinantGaussian(matrix) {<br>    const n = matrix.length;<br>    <br>    // Crear copia para no modificar original<br>    const mat = matrix.map(row => [...row]);<br>    let det = 1;<br>    let swaps = 0;<br>    <br>    // Eliminaci√≥n hacia adelante<br>    for (let i = 0; i < n; i++) {<br>        // Buscar pivote<br>        let maxRow = i;<br>        for (let k = i + 1; k < n; k++) {<br>            if (Math.abs(mat[k][i]) > Math.abs(mat[maxRow][i])) {<br>                maxRow = k;<br>            }<br>        }<br>        <br>        // Intercambiar filas si es necesario<br>        if (maxRow !== i) {<br>            [mat[i], mat[maxRow]] = [mat[maxRow], mat[i]];<br>            swaps++;<br>        }<br>        <br>        // Si el pivote es 0, el determinante es 0<br>        if (Math.abs(mat[i][i]) < 1e-10) {<br>            return 0;<br>        }<br>        <br>        // Eliminaci√≥n<br>        for (let k = i + 1; k < n; k++) {<br>            const factor = mat[k][i] / mat[i][i];<br>            for (let j = i; j < n; j++) {<br>                mat[k][j] -= factor * mat[i][j];<br>            }<br>        }<br>        <br>        // Multiplicar diagonal<br>        det *= mat[i][i];<br>    }<br>    <br>    // Ajustar por intercambios de filas<br>    return swaps % 2 === 0 ? det : -det;<br>}<br>```<br><br><strong>Regla de Sarrus (Solo para 3x3):</strong><br>```javascript<br>function determinant3x3Sarrus(matrix) {<br>    if (matrix.length !== 3 || !matrix.every(row => row.length === 3)) {<br>        throw new Error('Matrix must be 3x3');<br>    }<br>    <br>    const [[a, b, c], [d, e, f], [g, h, i]] = matrix;<br>    <br>    const positive = a*e*i + b*f*g + c*d*h;<br>    const negative = c*e*g + a*f*h + b*d*i;<br>    <br>    return positive - negative;<br>}<br>```<br><br><strong>Calculadora de Determinantes con Pasos:</strong><br>```javascript<br>class DeterminantCalculator {<br>    constructor(matrix) {<br>        this.matrix = matrix;<br>        this.steps = [];<br>    }<br>    <br>    calculate() {<br>        this.steps = [];<br>        const result = this.detWithSteps(this.matrix, 0);<br>        return { determinant: result, steps: this.steps };<br>    }<br>    <br>    detWithSteps(matrix, level) {<br>        const n = matrix.length;<br>        <br>        this.steps.push({<br>            level,<br>            matrix: matrix.map(row => [...row]),<br>            operation: `Calculating ${n}x${n} determinant`<br>        });<br>        <br>        if (n === 1) {<br>            return matrix[0][0];<br>        }<br>        <br>        if (n === 2) {<br>            const det = matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0];<br>            this.steps.push({<br>                level,<br>                operation: `2x2: (${matrix[0][0]})(${matrix[1][1]}) - (${matrix[0][1]})(${matrix[1][0]}) = ${det}`<br>            });<br>            return det;<br>        }<br>        <br>        let det = 0;<br>        for (let col = 0; col < n; col++) {<br>            const sign = col % 2 === 0 ? 1 : -1;<br>            const element = matrix[0][col];<br>            <br>            if (element !== 0) {<br>                const subMatrix = getSubMatrix(matrix, 0, col);<br>                const subDet = this.detWithSteps(subMatrix, level + 1);<br>                const contribution = sign * element * subDet;<br>                det += contribution;<br>                <br>                this.steps.push({<br>                    level,<br>                    operation: `${sign > 0 ? '+' : '-'}(${element}) √ó (${subDet}) = ${contribution}`<br>                });<br>            }<br>        }<br>        <br>        return det;<br>    }<br>}<br>```<br><br><strong>Propiedades del Determinante:</strong><br>```javascript<br>function determinantProperties(matrix) {<br>    const det = determinant(matrix);<br>    <br>    return {<br>        determinant: det,<br>        isInvertible: Math.abs(det) > 1e-10,<br>        isOrthogonal: Math.abs(Math.abs(det) - 1) < 1e-10,<br>        volume: Math.abs(det), // Para transformaciones geom√©tricas<br>        orientation: det > 0 ? 'preserving' : 'reversing'<br>    };<br>}<br>```<br><br><strong>L√≥gica:</strong> Usar expansi√≥n por cofactores recursivamente o eliminaci√≥n gaussiana para matrices grandes."
      },
      {
        "id": "euler-totient",
        "title": "Euler's Totient Function",
        "type": "logic-problem",
        "content": "<strong>Problema:</strong> Calcular œÜ(n) - la cantidad de enteros positivos ‚â§ n que son coprimos con n.<br><br><strong>Definici√≥n:</strong> œÜ(n) = cantidad de n√∫meros k donde 1 ‚â§ k ‚â§ n y gcd(k,n) = 1<br><br><strong>Ejemplos:</strong><br>‚Ä¢ œÜ(1) = 1<br>‚Ä¢ œÜ(6) = 2 (n√∫meros 1,5 son coprimos con 6)<br>‚Ä¢ œÜ(9) = 6 (n√∫meros 1,2,4,5,7,8)<br><br><strong>Soluci√≥n B√°sica (Fuerza Bruta):</strong><br>```javascript<br>function gcd(a, b) {<br>    return b === 0 ? a : gcd(b, a % b);<br>}<br><br>function eulerTotientBasic(n) {<br>    if (n === 1) return 1;<br>    <br>    let count = 0;<br>    for (let i = 1; i <= n; i++) {<br>        if (gcd(i, n) === 1) {<br>            count++;<br>        }<br>    }<br>    return count;<br>}<br>```<br><br><strong>F√≥rmula de Euler (Usando Factorizaci√≥n Prima):</strong><br>```javascript<br>function primeFactorization(n) {<br>    const factors = new Map();<br>    <br>    // Factor de 2<br>    while (n % 2 === 0) {<br>        factors.set(2, (factors.get(2) || 0) + 1);<br>        n /= 2;<br>    }<br>    <br>    // Factores impares<br>    for (let i = 3; i <= Math.sqrt(n); i += 2) {<br>        while (n % i === 0) {<br>            factors.set(i, (factors.get(i) || 0) + 1);<br>            n /= i;<br>        }<br>    }<br>    <br>    if (n > 2) {<br>        factors.set(n, 1);<br>    }<br>    <br>    return factors;<br>}<br><br>function eulerTotient(n) {<br>    if (n === 1) return 1;<br>    <br>    const primeFactors = primeFactorization(n);<br>    let result = n;<br>    <br>    // Aplicar f√≥rmula: œÜ(n) = n √ó ‚àè(1 - 1/p) para cada primo p que divide n<br>    for (const prime of primeFactors.keys()) {<br>        result = result * (prime - 1) / prime;<br>    }<br>    <br>    return Math.round(result);<br>}<br>```<br><br><strong>Versi√≥n Optimizada sin Factorizaci√≥n Completa:</strong><br>```javascript<br>function eulerTotientOptimized(n) {<br>    let result = n;<br>    let temp = n;<br>    <br>    // Verificar factor de 2<br>    if (temp % 2 === 0) {<br>        while (temp % 2 === 0) {<br>            temp /= 2;<br>        }<br>        result -= result / 2;<br>    }<br>    <br>    // Verificar factores impares<br>    for (let i = 3; i <= Math.sqrt(temp); i += 2) {<br>        if (temp % i === 0) {<br>            while (temp % i === 0) {<br>                temp /= i;<br>            }<br>            result -= result / i;<br>        }<br>    }<br>    <br>    // Si temp > 1, entonces es un primo<br>    if (temp > 1) {<br>        result -= result / temp;<br>    }<br>    <br>    return Math.round(result);<br>}<br>```<br><br><strong>Calcular œÜ(n) para Rango de N√∫meros (Criba):</strong><br>```javascript<br>function eulerTotientSieve(limit) {<br>    const phi = Array(limit + 1).fill(0).map((_, i) => i);<br>    <br>    for (let i = 2; i <= limit; i++) {<br>        if (phi[i] === i) { // i es primo<br>            for (let j = i; j <= limit; j += i) {<br>                phi[j] -= phi[j] / i;<br>            }<br>        }<br>    }<br>    <br>    return phi;<br>}<br>```<br><br><strong>Propiedades y Aplicaciones:</strong><br>```javascript<br>function totientProperties(n) {<br>    const phi = eulerTotient(n);<br>    <br>    return {<br>        phi: phi,<br>        isPrime: phi === n - 1,<br>        isPowerOfPrime: isPowerOfPrime(n),<br>        sumOfDivisors: sumOfDivisorsUsingTotient(n),<br>        // Teorema de Euler: a^œÜ(n) ‚â° 1 (mod n) si gcd(a,n) = 1<br>        eulerTheorem: (a) => gcd(a, n) === 1 ? modPow(a, phi, n) === 1 : false<br>    };<br>}<br><br>function isPowerOfPrime(n) {<br>    if (n <= 1) return false;<br>    <br>    for (let i = 2; i <= Math.sqrt(n); i++) {<br>        if (n % i === 0) {<br>            let temp = n;<br>            while (temp % i === 0) {<br>                temp /= i;<br>            }<br>            return temp === 1;<br>        }<br>    }<br>    return true; // n es primo<br>}<br><br>function modPow(base, exp, mod) {<br>    let result = 1;<br>    base = base % mod;<br>    while (exp > 0) {<br>        if (exp % 2 === 1) {<br>            result = (result * base) % mod;<br>        }<br>        exp = Math.floor(exp / 2);<br>        base = (base * base) % mod;<br>    }<br>    return result;<br>}<br>```<br><br><strong>Aplicaci√≥n en Criptograf√≠a RSA:</strong><br>```javascript<br>function rsaKeyGeneration(p, q) {<br>    // p y q deben ser primos grandes<br>    const n = p * q;<br>    const phiN = (p - 1) * (q - 1); // œÜ(n) cuando n = p√óq<br>    <br>    // Elegir e tal que gcd(e, œÜ(n)) = 1<br>    let e = 65537; // Valor com√∫n en RSA<br>    while (gcd(e, phiN) !== 1) {<br>        e++;<br>    }<br>    <br>    // Calcular d tal que e√ód ‚â° 1 (mod œÜ(n))<br>    const d = modInverse(e, phiN);<br>    <br>    return {<br>        publicKey: { n, e },<br>        privateKey: { n, d },<br>        phi: phiN<br>    };<br>}<br><br>function modInverse(a, m) {<br>    // Algoritmo extendido de Euclides para encontrar inverso modular<br>    const extGCD = (a, b) => {<br>        if (a === 0) return [b, 0, 1];<br>        const [gcd, x1, y1] = extGCD(b % a, a);<br>        const x = y1 - Math.floor(b / a) * x1;<br>        const y = x1;<br>        return [gcd, x, y];<br>    };<br>    <br>    const [gcd, x, _] = extGCD(a % m, m);<br>    if (gcd !== 1) throw new Error('Modular inverse does not exist');<br>    return ((x % m) + m) % m;<br>}<br>```<br><br><strong>L√≥gica:</strong> Usar la f√≥rmula œÜ(n) = n √ó ‚àè(1 - 1/p) donde p son los factores primos √∫nicos de n."
      },
      {
        "id": "josephus-problem",
        "title": "Josephus Problem",
        "type": "logic-problem",
        "content": "<strong>Problema:</strong> En un c√≠rculo de n personas, eliminando cada k-√©sima persona, encontrar la posici√≥n del sobreviviente.<br><br><strong>Historia:</strong> Josephus y 40 soldados en una cueva, eliminando cada 3ra persona.<br><br><strong>Ejemplos:</strong><br>‚Ä¢ n=7, k=3: Posiciones eliminadas: 3,6,2,7,5,1. Sobrevive: 4<br>‚Ä¢ n=5, k=2: Sobreviviente en posici√≥n 3<br><br><strong>Soluci√≥n Recursiva (0-indexed):</strong><br>```javascript<br>function josephus(n, k) {<br>    if (n === 1) {<br>        return 0; // 0-indexed<br>    }<br>    return (josephus(n - 1, k) + k) % n;<br>}<br><br>// Versi√≥n 1-indexed<br>function josephus1Indexed(n, k) {<br>    return josephus(n, k) + 1;<br>}<br>```<br><br><strong>Soluci√≥n Iterativa:</strong><br>```javascript<br>function josephusIterative(n, k) {<br>    let position = 0;<br>    for (let i = 2; i <= n; i++) {<br>        position = (position + k) % i;<br>    }<br>    return position + 1; // Convertir a 1-indexed<br>}<br>```<br><br><strong>Simulaci√≥n Completa del Proceso:</strong><br>```javascript<br>function josephusSimulation(n, k) {<br>    const people = Array.from({ length: n }, (_, i) => i + 1);<br>    const eliminationOrder = [];<br>    let currentIndex = 0;<br>    <br>    while (people.length > 1) {<br>        // Encontrar siguiente persona a eliminar<br>        currentIndex = (currentIndex + k - 1) % people.length;<br>        <br>        // Eliminar persona<br>        const eliminated = people.splice(currentIndex, 1)[0];<br>        eliminationOrder.push(eliminated);<br>        <br>        // Ajustar √≠ndice si estamos al final<br>        if (currentIndex >= people.length) {<br>            currentIndex = 0;<br>        }<br>    }<br>    <br>    return {<br>        survivor: people[0],<br>        eliminationOrder,<br>        steps: eliminationOrder.length<br>    };<br>}<br>```<br><br><strong>Versi√≥n con Lista Enlazada Circular:</strong><br>```javascript<br>class CircularNode {<br>    constructor(value) {<br>        this.value = value;<br>        this.next = null;<br>    }<br>}<br><br>function josephusCircularList(n, k) {<br>    // Crear lista circular<br>    const head = new CircularNode(1);<br>    let current = head;<br>    <br>    for (let i = 2; i <= n; i++) {<br>        current.next = new CircularNode(i);<br>        current = current.next;<br>    }<br>    current.next = head; // Cerrar el c√≠rculo<br>    <br>    // Eliminar nodos<br>    current = head;<br>    const eliminated = [];<br>    <br>    while (current.next !== current) {<br>        // Avanzar k-1 posiciones<br>        for (let i = 1; i < k; i++) {<br>            current = current.next;<br>        }<br>        <br>        // Eliminar siguiente nodo<br>        const nodeToRemove = current.next;<br>        eliminated.push(nodeToRemove.value);<br>        current.next = nodeToRemove.next;<br>        <br>        // Mover al siguiente nodo despu√©s del eliminado<br>        current = current.next;<br>    }<br>    <br>    return {<br>        survivor: current.value,<br>        eliminated<br>    };<br>}<br>```<br><br><strong>Variante: Josephus con Direcci√≥n Variable:</strong><br>```javascript<br>function josephusWithDirection(n, k, clockwise = true) {<br>    const people = Array.from({ length: n }, (_, i) => i + 1);<br>    const eliminated = [];<br>    let currentIndex = 0;<br>    <br>    while (people.length > 1) {<br>        if (clockwise) {<br>            currentIndex = (currentIndex + k - 1) % people.length;<br>        } else {<br>            currentIndex = (currentIndex - k + people.length) % people.length;<br>        }<br>        <br>        eliminated.push(people.splice(currentIndex, 1)[0]);<br>        <br>        if (currentIndex >= people.length) {<br>            currentIndex = 0;<br>        }<br>    }<br>    <br>    return { survivor: people[0], eliminated };<br>}<br>```<br><br><strong>Encontrar k para un Sobreviviente Deseado:</strong><br>```javascript<br>function findKForSurvivor(n, desiredSurvivor) {<br>    // Buscar k tal que el sobreviviente sea la posici√≥n deseada<br>    for (let k = 1; k <= n; k++) {<br>        if (josephus1Indexed(n, k) === desiredSurvivor) {<br>            return k;<br>        }<br>    }<br>    return -1; // No encontrado<br>}<br>```<br><br><strong>An√°lisis de Patrones:</strong><br>```javascript<br>function analyzeJosephusPatterns(maxN, k) {<br>    const patterns = [];<br>    <br>    for (let n = 1; n <= maxN; n++) {<br>        const survivor = josephus1Indexed(n, k);<br>        patterns.push({ n, survivor, k });<br>    }<br>    <br>    return patterns;<br>}<br><br>// Caso especial: k=2 (cada segunda persona)<br>function josephusK2(n) {<br>    // F√≥rmula cerrada para k=2<br>    const m = Math.floor(Math.log2(n));<br>    const l = n - Math.pow(2, m);<br>    return 2 * l + 1;<br>}<br>```<br><br><strong>Aplicaciones Modernas:</strong><br>```javascript<br>// Distribuci√≥n de tareas en sistemas distribuidos<br>function taskDistribution(tasks, workers, eliminationRate) {<br>    return josephusSimulation(workers, eliminationRate);<br>}<br><br>// Algoritmo de elecci√≥n de l√≠der<br>function leaderElection(nodeIds, stepSize) {<br>    const n = nodeIds.length;<br>    const survivorIndex = josephus(n, stepSize);<br>    return nodeIds[survivorIndex];<br>}<br><br>// Optimizaci√≥n de cache (LRU simulation)<br>function cacheEviction(cacheSize, accessPattern) {<br>    // Simular eliminaci√≥n estilo Josephus para cache LRU<br>    return josephusSimulation(cacheSize, accessPattern);<br>}<br>```<br><br><strong>L√≥gica:</strong> Usar la relaci√≥n de recurrencia J(n,k) = (J(n-1,k) + k) % n con caso base J(1,k) = 0."
      }
    ]
  }
}
