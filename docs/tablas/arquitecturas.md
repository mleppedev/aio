# Contexto y Propósito

## ¿Qué es?
La arquitectura de software es la forma en que organizamos los componentes, reglas y flujos de un sistema para hacerlo mantenible, escalable y seguro. Los patrones arquitectónicos (Clean, DDD, CQRS, Event-Driven, etc.) son guías probadas que ayudan a estructurar aplicaciones según distintos contextos de negocio y tecnológicos. No son recetas rígidas, sino marcos de decisión para enfrentar complejidad y cambio constante.

## ¿Por qué?
Porque la arquitectura define la vida útil de un sistema. Una mala elección lleva a deuda técnica, alto costo de cambios y limitaciones para escalar. En mi experiencia, proyectos municipales, bancarios y de retail han demostrado que la arquitectura correcta marca la diferencia entre una plataforma que soporta miles de usuarios y otra que se cae ante la primera carga inesperada. Además, patrones bien aplicados permiten alinear equipos técnicos y de negocio con un lenguaje común.

## ¿Para qué?
- **Diseñar sistemas sostenibles** que evolucionen sin necesidad de reescribirlos cada año.  
- **Asegurar calidad y resiliencia**, integrando microservicios, APIs y módulos críticos sin fricción.  
- **Reducir riesgos de integración** cuando conviven tecnologías diversas (SQL, NoSQL, colas, servicios externos).  
- **Alinear al negocio con la tecnología**, usando bounded contexts, eventos o separación de responsabilidades según necesidad.  

## Valor agregado desde la experiencia
- Aplicar **Clean/Hexagonal** permitió en retail migrar de SQL Server a MongoDB sin romper la lógica de negocio.  
- Con **DDD**, en un ERP municipal se lograron separar Finanzas, Recursos Humanos y Emergencias en contextos claros que redujeron acoplamiento.  
- **CQRS** fue clave en banca para manejar miles de consultas en tiempo real sobre precios sin afectar la consistencia de operaciones.  
- Una **arquitectura orientada a eventos** simplificó procesos en logística, donde un `PaqueteEntregado` disparaba notificaciones, facturación y encuestas de manera independiente.  

# Patrones Arquitectónicos

**Comparación detallada de los principales patrones arquitectónicos utilizados en desarrollo de software moderno.**
Esta tabla presenta los patrones más importantes con casos de uso específicos, beneficios y limitaciones de cada uno.
Fundamental para tomar decisiones arquitectónicas informadas según el contexto y requerimientos del proyecto.

| **Patrón**                                          | **Qué resuelve (detalle)**                                                                                                                      | **Casos de uso (5)**                                                                                                                                                                                                                                                                                                                                                                                                                      | **Pros (2)**                                                                                               | **Contras (2)**                                                                            |
| --------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------ |
| **Clean / Hexagonal (Ports & Adapters)**            | Aísla el **núcleo de negocio** de detalles técnicos (BD, APIs, UI, mensajería). Cambiar infraestructura no afecta la lógica de dominio.         | 1. API de Pedidos con persistencia en EF Core. <br> 2. Servicio de Pagos con integración a Stripe/PayPal. <br> 3. Notificaciones vía SMS/Email con Twilio. <br> 4. Servicio de Usuarios con autenticación externa (Azure AD). <br> 5. Microservicio de Reportes que cambia de SQL Server a MongoDB sin alterar lógica.                                                                                                                    | - Muy testeable, dominio aislado. <br> - Infraestructura reemplazable sin romper negocio.                  | - Mayor boilerplate y capas. <br> - Curva de aprendizaje si el equipo no conoce el patrón. |
| **DDD (Domain-Driven Design)**                      | Divide en **bounded contexts**, cada uno con reglas y lenguaje propio. Evita acoplamiento entre áreas de negocio.                               | 1. Retail: Pedidos, Inventario, Facturación. <br> 2. ERP: Compras, Finanzas, Recursos Humanos. <br> 3. Salud: Pacientes, Citas, Facturación médica. <br> 4. Transporte: Rutas, Flota, Pagos. <br> 5. Banca: Créditos, Cuentas, Riesgo.                                                                                                                                                                                                    | - Define límites claros, reduce dependencia. <br> - Lenguaje compartido con negocio (ubiquitous language). | - Difícil implementar en equipos pequeños. <br> - Mucha documentación y modelado inicial.  |
| **CQRS (Command Query Responsibility Segregation)** | Separa **escrituras (commands)** con reglas complejas de **lecturas (queries)** optimizadas. Ideal para sistemas con alta demanda de consultas. | 1. E-commerce: consultas masivas de catálogo vs. pocas compras. <br> 2. Trading financiero: miles de queries de precios vs. pocas operaciones. <br> 3. Red social: feed de publicaciones vs. creación de posts. <br> 4. IoT: millones de lecturas de sensores vs. pocas configuraciones. <br> 5. App de reservas: ver disponibilidad vs. confirmar reserva.                                                                               | - Escala bien en escenarios con más lecturas que escrituras. <br> - Queries rápidas y optimizadas.         | - Duplicación de modelos (command/read). <br> - Complejidad en sincronización de datos.    |
| **Event-Driven Architecture**                       | Desacopla microservicios con **eventos asincrónicos**. Permite que servicios reaccionen en paralelo sin depender directamente.                  | 1. E-commerce: evento `OrderPlaced` dispara inventario, facturación y notificación. <br> 2. Banca: `TransaccionRegistrada` dispara contabilidad, fraude, notificación. <br> 3. IoT: `SensorThresholdExceeded` dispara alerta y almacenamiento. <br> 4. Streaming: `NuevoVideoSubido` dispara indexado, notificaciones, recomendaciones. <br> 5. Logística: `PaqueteEntregado` dispara facturación, actualización de tracking y encuestas. | - Desacoplamiento alto, resiliencia. <br> - Escalabilidad horizontal con brokers (Kafka, RabbitMQ).        | - Difícil trazabilidad y debugging. <br> - Necesita monitoreo y observabilidad avanzados.  |
