# Patrones Arquitectónicos

**Comparación detallada de los principales patrones arquitectónicos utilizados en desarrollo de software moderno.**
Esta tabla presenta los patrones más importantes con casos de uso específicos, beneficios y limitaciones de cada uno.
Fundamental para tomar decisiones arquitectónicas informadas según el contexto y requerimientos del proyecto.

| **Patrón**                                          | **Qué resuelve (detalle)**                                                                                                                      | **Casos de uso (5)**                                                                                                                                                                                                                                                                                                                                                                                                                      | **Pros (2)**                                                                                               | **Contras (2)**                                                                            |
| --------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------ |
| **Clean / Hexagonal (Ports & Adapters)**            | Aísla el **núcleo de negocio** de detalles técnicos (BD, APIs, UI, mensajería). Cambiar infraestructura no afecta la lógica de dominio.         | 1. API de Pedidos con persistencia en EF Core. <br> 2. Servicio de Pagos con integración a Stripe/PayPal. <br> 3. Notificaciones vía SMS/Email con Twilio. <br> 4. Servicio de Usuarios con autenticación externa (Azure AD). <br> 5. Microservicio de Reportes que cambia de SQL Server a MongoDB sin alterar lógica.                                                                                                                    | - Muy testeable, dominio aislado. <br> - Infraestructura reemplazable sin romper negocio.                  | - Mayor boilerplate y capas. <br> - Curva de aprendizaje si el equipo no conoce el patrón. |
| **DDD (Domain-Driven Design)**                      | Divide en **bounded contexts**, cada uno con reglas y lenguaje propio. Evita acoplamiento entre áreas de negocio.                               | 1. Retail: Pedidos, Inventario, Facturación. <br> 2. ERP: Compras, Finanzas, Recursos Humanos. <br> 3. Salud: Pacientes, Citas, Facturación médica. <br> 4. Transporte: Rutas, Flota, Pagos. <br> 5. Banca: Créditos, Cuentas, Riesgo.                                                                                                                                                                                                    | - Define límites claros, reduce dependencia. <br> - Lenguaje compartido con negocio (ubiquitous language). | - Difícil implementar en equipos pequeños. <br> - Mucha documentación y modelado inicial.  |
| **CQRS (Command Query Responsibility Segregation)** | Separa **escrituras (commands)** con reglas complejas de **lecturas (queries)** optimizadas. Ideal para sistemas con alta demanda de consultas. | 1. E-commerce: consultas masivas de catálogo vs. pocas compras. <br> 2. Trading financiero: miles de queries de precios vs. pocas operaciones. <br> 3. Red social: feed de publicaciones vs. creación de posts. <br> 4. IoT: millones de lecturas de sensores vs. pocas configuraciones. <br> 5. App de reservas: ver disponibilidad vs. confirmar reserva.                                                                               | - Escala bien en escenarios con más lecturas que escrituras. <br> - Queries rápidas y optimizadas.         | - Duplicación de modelos (command/read). <br> - Complejidad en sincronización de datos.    |
| **Event-Driven Architecture**                       | Desacopla microservicios con **eventos asincrónicos**. Permite que servicios reaccionen en paralelo sin depender directamente.                  | 1. E-commerce: evento `OrderPlaced` dispara inventario, facturación y notificación. <br> 2. Banca: `TransaccionRegistrada` dispara contabilidad, fraude, notificación. <br> 3. IoT: `SensorThresholdExceeded` dispara alerta y almacenamiento. <br> 4. Streaming: `NuevoVideoSubido` dispara indexado, notificaciones, recomendaciones. <br> 5. Logística: `PaqueteEntregado` dispara facturación, actualización de tracking y encuestas. | - Desacoplamiento alto, resiliencia. <br> - Escalabilidad horizontal con brokers (Kafka, RabbitMQ).        | - Difícil trazabilidad y debugging. <br> - Necesita monitoreo y observabilidad avanzados.  |
